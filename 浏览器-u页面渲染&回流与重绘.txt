一、页面的呈现过程：（Webkit 渲染引擎流程） 
	webkit 作为浏览器的渲染引擎能够将 html/css/js 文本及相应的资源文件转换成图像结果。
		1、浏览器解析 HTML ，并构建 DOM 树（步骤如下）
		（1）转码: 浏览器将接收到的二进制数据按照指定编码格式转化为 HTML 字符串
		（2）生成 Tokens: 之后开始 parser，浏览器会将 HTML 字符串解析成 Tokens
		（3）构建 Nodes: 对 Node 添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope
		（4）生成 DOM Tree：通过 node 包含的指针确定的关系构建出 DOM Tree

		2、进行 CSS 解析，构建 CSS 规则树（CSSOM）（样式结构体）
		（浏览器如何解析 css 选择器？
		浏览器读取到选择器时，会从 DOM 树中找到匹配的对应节点，然后将样式附着到对应的 DOM 元素上。
		当选择器出现多个层级时，浏览器会使用「从右到左」的顺序进行匹配，对应到 DOM 树的遍历上，
		是从叶子到根的方向进行筛选，这样可以提升匹配效率）
		3、DOM Tree 和 CSSOM Tree 合成一棵渲染树 （Render Tree）
		4、进入布局（Layout）阶段，根据渲染树来布局，计算每个节点的具体位置
		5、调用 GPU 进行绘制，遍历 Render Tree 的节点，合成图层，显示在屏幕上



二、页面的回流与重绘：
	回流：当 render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，
	这就称为回流（就像是重新布局）。每个页面至少需要一次回流，就是在页面第一次加载的时候。

	重绘：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不影响布局的，
	比如 background-color、visibility 等，这就称为重绘。

	注：回流必将引起重绘，而重绘不一定会引起回流。
		如果回流的频率很高，CPU 使用率大大增加，性能代价很高



会引起回流、重绘的操作：
	其实任何对 render tree 中元素的操作都会引起回流或者重绘，比如：
	1、添加、删除元素（回流+重绘）
	2、隐藏元素，display：none（回流+重绘），visibility：hidden（只重绘，不回流）
	3、移动元素，比如改变top,left （jquery 的 animate 方法就是，改变 top,left 不一定会影响回流），
	或者移动元素到另外1个父元素中（回流+重绘）
	4、对 style 的操作
	5、用户的操作，例：改变浏览器大小，字体大小等（回流+重绘）



减少回流、重绘的方法：（其实就是需要减少 render tree 的操作）
	1、尽量不要使用内联样式style属性，避免设置多层内联样式，
	2、不要逐条的修改 DOM 的样式，如果想修改一个 DOM 节点的多个 css 属性值，
	可以预先定义好 class，一次性修改，这样只会触发一次回流。
	3、在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量
	4、尽可能在 dom 树末端改变 class
	5、对于视频使用 video 标签
	6、动画效果应用到 position 属性为 absolute 或 fixed 的元素上（动画元素脱离文档流）
	7、避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
	8、不要把DOM节点的属性值放在一个循环里当成循环里的变量，避免循环操作 dom
	9、可以把 DOM 离线后修改，先设置 display:none 进行操作，修改完之后，最终把它显示出来。
	因为 display:none 上的 DOM 操作不会引发回流和重绘。
	10、增加多个节点使用documentFragment：不是真实dom的部分，不会引起重绘和回流
	11、用 translate 代替 top ，因为 top 会触发回流，但是translate不会。
	所以translate会比top节省了一个layout的时间























