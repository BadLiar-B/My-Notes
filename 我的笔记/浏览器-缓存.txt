一、浏览器缓存机制的关键就是：
1、浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
2、浏览器每次拿到返回的请求结果，都会将该结果和缓存标识存入浏览器缓存中

上述两点保证了每个请求的缓存存入与读取

选择合适的缓存策略：
对于一次性的资源，比如验证码图片，不进行缓存。设置响应头 cache-control: no-store。
对于频繁变动的资源，比如某些数据接口，使用 协商缓存。设置响应头 cache-control: no-cache，同时配合 ETag 标记，让浏览器缓存资源，但每次都会发送请求询问资源是否更新。
对于静态资源，比如 JS、CSS、图片等文件，使用 强制缓存。设置响应头 cache-control: max-age= 有效时长，设置一个很长的过期时间，比如十年，然后通过文件 hash 的处理更新

二、强制缓存 / 协商缓存
1、强制缓存的缓存规则就是：当浏览器向服务器发送请求的时候，服务器会将缓存规则放入 HTTP 响应的报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control ，其中 Cache-Conctrol 的优先级比 Expires 高。

（Expires：值是一个绝对时间，在这个时间前缓存有效，如果本地时间被修改，会导致缓存失效）
（Cache-control：值是一个相对时间，单位：秒，资源在这个时间内有效）
	Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间，即再次发送请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。
	Expires 是 HTTP/1.0 的字段，但是现在浏览器的默认使用的是 HTTP/1.1，到了 HTTP/1.1，Expires 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因发生误差，那么强制缓存直接失效。

2、协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
两种实现方案：
	Last-Modified 和 If-Modified-Since：Last-Modified 表示本地文件最后修改日期，
	If-modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期之后资源是否有更新，
	有更新的话就会将新的资源发送回来。
	Etag 和 If-None-Match：Etag 类似于文件指纹，If-None-Match 会将当前 Etag 发送给服务器，
	询问该资源 Etag 是否变动，有变动的话就将新的资源发送回来。Etag 的优先级高于 Last-Modified。


三、浏览器缓存读取规则：
当需要获取一个资源时，浏览器会先检查缓存中是否存在，若命中缓存，则不会发送请求。

浏览器按照一定的顺序检查缓存，具体顺序是：
1、service worker：在 service worker 中，开发者可以根据需要将远程获取的资源缓存到 cache storage 中，之后对该资源的请求会直接从缓存中获取。
这部分缓存需要前端开发者手动完成的
2、memory cache：浏览器会自动将请求过的资源自动加入到 memory cache，这主要是为了解决一个页面中有多次相同的请求，比如页面中链接了多张相同的图片。
（memory cache 是浏览器自动完成的，它不关心 http 语义，但会遵守 `cache-control: no-store` 指令。浏览器在请求资源后，会自动将资源加入 memory cache，在后续的请求中，若请求的 url 地址和之前缓存的对应地址相同，则直接使用 memory cache。memory cache 只缓存 get 请求，并且缓存的内容在内存中，因此会很快的清理。）
3、disk cache：当浏览器得到的响应头中包含cache-control等缓存指令时，会按照指令的要求设置 disk cache。请求的资源会被保存在磁盘中，在指定的期限内有效。
（disk cache 遵守 http 缓存语义，它会按照服务器响应头中指定的缓存要求进行缓存，由于它存在于磁盘中，是长期的，因此，即便浏览器关闭后缓存内容也不会消失。它的保存时间由服务器的 `cache-control` 字段指定，当缓存失效后，会重新发送请求到服务器，进入协商缓存的流程。）



