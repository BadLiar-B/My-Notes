一、客户端渲染效率比 vue2 提升了1.3-2倍
SSR 渲染效率比 vue2 提升了2-3倍

vue3 的效率提升主要体现在哪些方面？
静态提升：（vue3 中对不参与更新的元素会做静态提升，只会被创建一次，在渲染时直接复用）
	下面的静态节点会被提升：
	元素节点、没有绑定动态内容、静态属性也会被提升
	（createVNode会提5升到render函数上，在render函数里直接调用）
预字符串化：
	当编译器遇到大量连续的静态内容，会直接将其编译为一个普通字符串节点
缓存事件处理函数：
	保证事件处理函数只生成一次，下一次直接调用
Block Tree：
	在 vue2 里，所有节点会依次对比，vue3 会在跟节点的时候记录所有后代中哪些节点是动态的，编译器记录。
	对比的时候，直接找到根节点（block节点），对比里面的动态节点。（是个数组）
PatchFlag：
	vue2 在对比每一个节点时， 并不知道这个节点哪些相关信息会发生相关变化，因此只能将所有信息依次对比。
	vue3 在编译器编译完之后，会标记哪些是动态的，就是 patchFlag ，直接对比元素的内容
diff 算法优化：
	vue3 在 diff 算法中相比 vue2 增加了静态标记其作用是为了会发生变化的地方添加一个 flag 标记
源码体积：
	源码体积变小了，移除了一些不常用的 api，并且任何一个函数只有用到的时候才会打包，没用到的模块都被摇掉，打包的整体体积变小




二、vue3 为什么去掉了 vue 构造函数？
如果一个页面有多个 vue 应用时，就会遇到一些问题
	Vue.use(...)、Vue.mixin(...)、Vue.component(...)
在 vue3 中，去掉了 vue 构造函数，转而使用 createApp 创建 vue 应用
	createApp(根组件).use(...).mixin(...).component(...).mount("#app1")
	createApp(根组件).mount("#app2")
标准回答：因为 vue2 的全局构造函数带来了诸多问题：
1. 调用构造函数的静态方法会对所有vue应用生效，不利于隔离不同应用（情况少）
2. vue2 的构造函数集成了太多功能，不利于 tree shaking，vue3 把这些功能使用普通函数导出，能够充分利用 tree shaking 优化打包体积
3. vue2 没有把组件实例和 vue 应用两个概念区分开，在 vue2 中，通过 new Vue 创建的对象，既是一个 vue 应用，同时又是一个特殊的 vue 组件。vue3 中，把两个概念区别开来，通过 createApp 创建的对象，是一个 vue 应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件。



三、谈谈你对 vue3 数据响应式的理解：
1、vue3 不再使用 Object.defineProperty 的方式定义完成数据响应式，而是使用 Proxy。
	Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应
	Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。
	Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
	Proxy 有多达 13 种拦截方法
	Proxy作为新标准将受到浏览器厂商重点持续的性能优化
2、除了 Proxy 本身效率比 Object.defineProperty 更高之外，由于不必递归遍历所有属性，而是直接得到一个 Proxy。所以在 vue3 中，对数据的访问是动态的，当访问某个属性的时候，再动态的获取和设置，这就极大的提升了在组件初始阶段的效率。
3、同时，由于 Proxy 可以监控到成员的新增和删除，因此，在 vue3 中新增成员、删除成员、索引访问等均可以触发重新渲染，而这些在 vue2 中是难以做到的。

问题一、Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？
判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。

问题二、监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？
我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。



