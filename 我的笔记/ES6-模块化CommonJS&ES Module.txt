一、为什么需要模块化？
当前端工程到达一定规模后，就会出现下面的问题：
全局变量污染、依赖混乱
上面的问题，共同导致了代码文件难以细分，模块化就是为了解决上面两个问题出现的
模块化出现后，我们就可以把臃肿的代码细分到各个小文件中，便于后期维护管理

模块化有哪几种标准？
目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统



二、前端模块化标准：前端主要有两大模块化标准：
1、CommonJS，简称 CMJ，这是一个社区规范，出现时间较早，使用函数实现，目前仅 node 环境支持
	依赖类型：支持动态依赖（同步进行的）

	导出：module.exports = 导出的值
	导入：require("模块路径") // 函数返回模块导出的值

2、ES Module，简称 ESM，这是随着 ES6 发布的官方模块化标准，使用新语法实现，目前浏览器和新版本 node 环境均支持
	依赖类型：支持静态依赖，动态依赖（动态依赖是异步的）
	ESM 导入时有符号绑定，CMS 只是普通函数调用和赋值
	导出：export= xxx 	普通导出（具名导出），可以导出多个，必须带有命名。
		export default = 默认导出，只能导出一个，无需命名
	导入：import xxx from ./xxx.js 


require 和 import 的区别：import 和 require 都是被模块化使用
 1、	requrire 是 commonJS 的语法，commonjs 的模块是对象
	import 是 es6 的语法标准，es6 模块不是对象
 2、	require 是运行时加载整个模块，生成一个对象，再从对象上读取他的方法，理论上可以用在代码的任何地方
	import 是编译时调用，确定模块的依赖关系，输入变量，import 具有提升效果，会提升到模块的头部
 3、	require 是赋值过程，把 require 的结果默认是 export 的一个对象，赋给某个变量
	import 是解构过程 




三、CommonJS 如何实现模块化
node 天生支持 CommonJS 模块化标准
node 规定：
node 中的每个 js 文件都是一个 CMJ 模块，通过 node 命令运行的模块，叫做入口模块
模块中的所有全局定义的变量、函数，都不会污染到其他模块
模块可以暴露（导出）一些内容给其他模块使用，需要暴露什么内容，就在模块中给 module.exports 赋值
一个模块可以导入其他模块，使用函数 require("要导入的模块路径") 即可完成，该函数返回目标模块的导出结果
	导入模块时，可以省略 .js
	导入模块时，必须以 ./ 或 ../ 开头
一个模块在被导入时会运行一次，然后它的导出结果会被 node 缓存起来，后续对该模块导入时，不会重新运行，直接使用缓存结果





