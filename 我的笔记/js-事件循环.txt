一、事件循环：又叫消息循环，是浏览器渲染主线程的工作方式。
	根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务属于不同的队列。不同的任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。
	在 Chrome 的源码中，他会开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

（单线程是异步产生的原因，事件循环是异步的实现方式）



二、界面的第一次渲染：初始化同步代码==>清空所有的微任务==>渲染界面==>执行第一个宏任务==>所有的微任务==>渲染界面==>执行第一个宏任务

界面的更新渲染：所有的微任务==>渲染界面==>执行第一个宏任务

总结：清空微队列中的所有微任务==>渲染界面==>执行宏队列的第一个宏任务


三、执行顺序：
1、先执行同步任务： 执行器: new Promise(function(){}) // await b( ) // alert(...) // console.log(...) // 函数执行:a( ) // 

2、再执行异步任务：
先清空所有的微任务，再执行第一个宏任务，再执行所有的微任务，再执行第一个宏任务 

微任务队列：Promise.then( )中的回调函数 // async/await(await之后的代码属于微任务，相当于promise.then) // 

宏任务队列：DOM监听事件: document.getElementById... // setTimeOut(...) // setInterval(...) // Ajax请求 // script（代码块）




四、扩展：node 中的事件循环机制：
	Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时（没有请求接入时），就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从线程池中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。
	当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)。

（1）Node.JS 的事件循环分为 6 个阶段：
timers 阶段：这个阶段执行 timer（ setTimeout、setInterval ）的回调
I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
idle、prepare 阶段：仅 Node.js 内部使用
poll 阶段：获取新的 I/O 事件, 适当的条件下 Node.js 将阻塞在这里
check 阶段：执行 setImmediate( ) 的回调
close callbacks 阶段：执行 socket 的 close 事件回调

（2）事件循环的执行顺序为：
外部输入数据 –-> 轮询阶段（ poll ）-–> 检查阶段（ check ）-–> 关闭事件回调阶段（ close callback ）–-> 定时器检测阶段（ timer ）–-> I/O 事件回调阶段（ I/O callbacks ）-–>闲置阶段（ idle、prepare ）–->轮询阶段（按照该顺序反复运行）...

（3）浏览器和 Node.js 环境下，微任务任务队列的执行时机不同：
Node.js 端，微任务在事件循环的各个阶段之间执行
浏览器端，微任务在事件循环的宏任务执行完之后执行

（4）Node.js v11.0.0 版本于 2018 年 10 月，主要有以下变化：
V8 引擎更新至版本 7.0
http、https 和 tls 模块默认使用 WHESWG URL 解析器。
隐藏子进程的控制台窗口默认改为了 true。
FreeBSD 10不再支持。
增加了多线程 Worker Threads



 