vue 性能优化：

1、路由懒加载、异步组件、防抖、节流

2、v-for 使用 key：对于通过循环生成的列表，应给每个列表项一个稳定且唯一的key，这有利于在列表变动时，尽量少的删除、新增、改动元素

3、使用冻结的对象：冻结的对象不会被响应化

4、使用函数式组件：参见函数式组件

5、使用计算属性：（合理使用 computed 和 watch）如果模板中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存它们

6、非实时绑定的表单项：
	当使用 v-model 绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致 vue 发生重渲染（rerender），这会带来一些性能的开销。
	特别是当用户改变表单项时，页面有一些动画正在进行中，由于 JS 执行线程和浏览器渲染线程是互斥的，最终会导致动画出现卡顿。
	我们可以通过使用 lazy 或不使用 v-model 的方式解决该问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。


7、保持对象引用稳定：在绝大部分情况下，vue 触发 rerender 的时机是其依赖的数据发生变化。若数据没有发生变化，哪怕给数据重新赋值了，vue 也是不会做出任何处理的

下面是 vue 判断数据没有变化的源码
// value 为旧值， newVal 为新值
if (newVal === value || (newVal !== newVal && value !== value)) {
  return
}
因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染。

对于原始数据类型，保持其值不变即可
对于对象类型，保持其引用不变即可
从另一方面来说，由于可以通过保持属性引用稳定来避免子组件的重渲染，那么我们应该细分组件来尽量避免多余的渲染


8、使用 v-show 替代 v-if ：（ v-for 的同时避免使用 v-if ）对于频繁切换显示状态的元素，使用 v-show 可以保证虚拟 dom 树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量 dom 元素的节点，这一点极其重要。
关键字：频繁切换显示状态、内部包含大量dom元素

9、使用延迟装载（defer）：
	首页白屏时间主要受到两个因素的影响：
	（1）打包体积过大：巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个<div>，没有可显示的内容
	（2）需要立即渲染的内容太多：JS传输完成后，浏览器开始执行JS构造页面。但可能一开始要渲染的组件太多，不仅JS执行的时间很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏。

打包体积过大需要自行优化打包体积，使用 webpack 的 plugin 插件压缩文件。
渲染内容太多的问题，一个可行的办法就是延迟装载组件，让组件按照指定的先后顺序依次一个一个渲染出来。延迟装载是一个思路，本质上就是利用 requestAnimationFrame 事件分批渲染内容，它的具体实现多种多样

10、第三方插件按需引入 Element UI

11、使用缓存（客户端缓存、服务端缓存）优化、服务端开启 gzip 压缩

12、destory 时销毁事件：比如 addEventListener 添加的事件、setTimeout、setInterval、bus.$on 绑定的监听事件等

13、使用 keep-alive
	keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。
	keep-alive 具有 include 和 exclude 属性，通过它们可以控制哪些组件进入缓存。另外它还提供了 max 属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。
	受 keep-alive 的影响，其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后

	在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象
	// keep-alive 内部的声明周期函数
	created () {
	  this.cache = Object.create(null)
	  this.keys = []
	}
	key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值。

	cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM。在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素


14、长列表优化
	【】虚拟滚动（Virtual Scrolling）：虚拟滚动是一种技术，它只渲染当前可见区域的列表项，而不是将整个列表都渲染到 DOM。通过动态添加和删除列表项，可以在滚动时实现高性能和流畅的体验。一些流行的虚拟滚动库包括 Vue Virtual Scroller 和 vue-virtual-scroll-list。
	【】分页加载（Pagination）：将长列表分割成多个页面或加载更多的方式，可以减少一次性加载大量数据所带来的性能问题。通过分页加载，只在需要时加载当前页面的数据，对服务器和客户端的资源消耗更加平衡。
	【】惰性渲染（Lazy Rendering）：惰性渲染是指延迟加载非首屏可见的列表项，只在需要时才进行加载。例如，当用户滚动到某个列表项时，再进行加载和显示。这可以减少初始加载时的渲染时间，提高页面响应速度。
	【】列表项重用（Item Recycling）：在滚动过程中，可以重用已渲染的列表项，而不是每次滚动都重新创建新的列表项。通过将已滚出视图的列表项进行回收和重用，可以减少 DOM 操作和内存占用。
	【】懒加载（Lazy Loading）：对于包含大量图片或复杂内容的列表项，可以采用懒加载的方式。只有当列表项进入可视区域时，才加载其内容，而不是一次性加载所有的内容。这可以加快初始渲染速度和降低资源消耗。
	【】数据缓存和分页缓存：在处理长列表时，可以使用数据缓存和分页缓存来减少重复的数据请求和处理。通过将已获取的数据进行缓存，可以避免重复请求同一数据。同时，对于已加载的分页数据，可以将其缓存起来，以便在用户返回之前的页面时快速恢复。
	【】搜索和过滤优化：针对长列表的搜索和过滤功能，可以使用索引或缓存来加速搜索过程，避免每次搜索都遍历整个列表。



