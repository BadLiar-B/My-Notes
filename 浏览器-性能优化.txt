一、网络优化：
	【】DNS 优化：1、减少 DNS 请求次数
		2、缩短 DNS 解析时间（dns-prefetech）（DNS 预解析）
		dns-prefetech：它根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，进而提高网站的访问速度。
例：link 标签的 rel 属性设置 dns-prefetch，提前获取域名对应的IP地址

	【】使用缓存：减轻服务端压力，快速得到数据，分为：强缓存 / 协商缓存
		1、强缓存：强缓存不需要客户端向服务端发送请求
		有两种响应头实现方案：（1）Expires：值是一个绝对时间，在这个时间前缓存有效，如果本地时间被修改，会导致缓存失效（2）Cache-control：值是一个相对时间，单位：秒，资源在这个时间内有效
		2、强缓存过期之后会使用协商缓存，协商缓存需要客户端向服务端发送请求，资源未过期则服务端返回 304，否则返回新的资源。
		协商缓存也有两种实现方案：（1）Last-Modified 和 If-Modified-Since：Last-Modified 表示本地文件最后修改日期，If-modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期之后资源是否有更新，有更新的话就会将新的资源发送回来。Etag 和 If-None-Match：Etag 类似于文件指纹，If-None-Match 会将当前 Etag 发送给服务器，询问该资源 Etag 是否变动，有变动的话就将新的资源发送回来。Etag 的优先级高于 Last-Modified。
		
	【】使用 CDN加载（内容分发网络）：用户与服务器的物理距离对响应时间也有影响
		内容分发网络（CDN）是一组分散在不同地理位置的 Web 服务器，用来给用户更高效的发送内容。
		典型的，选择用来发送内容的服务器是基于网络距离的衡量标准的。
		例如：选择跳数（hop）最少的或者响应时间最快的服务器。

	【】压缩响应：压缩组件通过减少 HTTP 请求产生的响应包的大小，从而降低传输时间的方式来提高性能。
		Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持，如果 Web 服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端使用哪种方法进行的压缩。目前许多网站通常会压缩 HTML 文档，脚本和样式表的压缩也是值得的。
	
	【】使用多个域名：
		使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗

	【】避免图片 src 为空：
		虽然 src 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求



二、页面渲染优化：
	【】Webkit 渲染引擎流程：webkit 作为浏览器的渲染引擎能够将 html/css/js 文本及相应的资源文件转换成图像结果。
		处理 HTML ，并构建 DOM 树
		处理 CSS ，构建 CSS 规则树（CSSOM）
		DOM Tree 和 CSSOM Tree 合成一棵渲染树 Render Tree。
		根据渲染树来布局，计算每个节点的位置
		调用 GPU 绘制，合成图层，显示在屏幕上

	【】避免 CSS 阻塞：
		css 影响 renderTree 的构建，会阻塞页面的渲染，因此应该尽早将 css 放在 head 标签里，或者尽快启用 CDN 实现静态资源加载速度的优化，将 css 资源加载。

	【】降低 CSS 选择器的复杂度：
		浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。
		减少嵌套，最多不要超过三层，并且后代选择器的开销较高，谨慎使用
		避免使用通配符，对用到的元素进行匹配即可
		利用继承，避免重复使用匹配和定义
		正确使用类选择器和 id 选择器

	【】避免使用 CSS 表达式：css 表达式会被频繁地计算。

	【】避免 js 阻塞：
		js 可以修改 CSSOM 和 DOM，因此 js 会阻塞页面的解析和渲染，并且会等待 css 资源的加载。也就是说 js 会抢走渲染引擎的控制权。所以我们需要给 js 资源添加 defer 或者 async，延迟js脚本的执行。

	【】使用外链式的 js 和 css：
		使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，HTML 文档通常不会被配置为可以进行缓存的。

	【】使用字体图标 iconfont 代替图片图标：
		图片会增加网络请求次数，从而拖慢页面加载时间。
		iconfont 可以很好的缩放并且不会添加额外的请求。

	【】首屏加载优化：
		使用骨架屏或者动画，优化用户体验
		资源按需加载，首页不需要的资源延迟加载
	【】减少重绘和回流：
		1、尽量不要是用内联样式 style 属性，避免设置多层内联样式，
		2、不要逐条的修改 DOM 的样式，如果想修改一个 DOM 节点的多个 css 属性值，
		可以预先定义好 class，一次性修改，这样只会触发一次回流。
		3、在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量
		4、尽可能在 dom 树末端改变 class
		5、对于视频使用 video 标签
		6、动画效果应用到 position 属性为 absolute 或 fixed 的元素上（动画元素脱离文档流）
		7、避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
		8、不要把DOM节点的属性值放在一个循环里当成循环里的变量，避免循环操作 dom
		9、可以把 DOM 离线后修改，先设置 display:none 进行操作，修改完之后，最终把它显示出来。
		因为 display:none 上的 DOM 操作不会引发回流和重绘。
		10、增加多个节点使用documentFragment：不是真实dom的部分，不会引起重绘和回流
		11、用 translate 代替 top ，因为 top 会触发回流，但是translate不会。
		所以translate会比top节省了一个layout的时间



三、JS 中的性能优化
	【】使用事件委托

	【】防抖和节流

	【】尽量不要使用 JS 动画：css3 动画和 canvas 动画都比 JS 动画性能好

	【】多线程：复杂的计算开启 webWorker 进行计算，避免页面假死

	【】计算结果缓存：减少运算次数，比如 vue 中的 computed



四、图片的优化
	【】雪碧图：借助减少http请求次数来进行优化

	【】图片懒加载：在图片即将进入可视区域的时候进行加载

	【】使用 CSS3 代替图片：有很多图片使用 CSS 效果（渐变、阴影等）就能画出来

	【】图片压缩：1、通过在线网站进行压缩 2、通过 webpack 插件 image-webpack-loader
		
	【】使用渐进式 jpeg：使用渐进式jpeg，会提高用户体验

	【】使用 webp 格式的图片：webp 是一种新的图片文件格式，它提供了有损压缩和无损压缩两种方式。在相同图片质量下，webp 的体积比 png 和 jpg 更小。



五、webpack 打包优化
	1、对传输性能的优化
	【】压缩和混淆：使用 Uglifyjs 或其他类似工具对打包结果进行压缩、混淆，可以有效的减少包体积
	【】tree shaking：项目中尽量使用 ES Module，可以有效利用 tree shaking 去除死代码优化，降低包体积
	【】抽离公共模块：将一些公共代码单独打包，这样可以充分利用浏览器缓存，其他代码变动后，不影响公共代码，浏览器可以直接从缓存中找到公共代码。具体方式有多种，比如 dll、splitChunks
	【】异步加载：对一些可以延迟执行的模块可以使用动态导入的方式异步加载它们，这样在打包结果中，它们会形成单独的包，同时，在页面一开始解析时并不需要加载它们，而是页面解析完成后，执行 JS 的过程中去加载它们。这样可以显著提高页面的响应速度，在单页应用中尤其有用。
	【】缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验。
	【】懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
	【】预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加 loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
	【】CDN：对一些知名的库使用 CDN，不仅可以节省打包时间，还可以显著提升库的加载速度
	【】gzip：目前浏览器普遍支持 gzip 格式，因此可以将静态文件均使用 gzip 进行压缩，能够有效的缩小传输资源的大小。
	【】环境适配：有些打包结果中包含了大量兼容性处理的代码，但在新版本浏览器中这些代码毫无意义。因此，可以把浏览器分为多个层次，为不同层次的浏览器给予不同的打包结果。
	【】图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
	【】使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求

	2、对打包过程的优化：
	【】noParse 配置：很多第三方库本身就是已经打包好的代码，对于这种代码无须再进行解析，可以使用 noParse 配置排除掉这些第三方库
	【】externals 配置：对于一些知名的第三方库可以使用 CDN，这部分库可以通过 externals 配置不进行打包
	【】限制 loader 的范围：在使用 loader 的时候，可以通过 exclude 排除掉一些不必要的编译，比如 babel-loader 对于那些已经完成打包的第三方库没有必要再降级一次，可以排除掉
	【】合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
	【】开启 loader 缓存：可以利用 cache-loader 缓存 loader 的编译结果，避免在源码没有变动时反复编译
	【】开启多线程编译：可以利用 thread-loader 开启多线程编译，提升编译效率
	【】动态链接库：对于某些需要打包的第三方库，可以使用 dll 的方式单独对其打包，然后 DLLPlugin 将其整合到当前项目中，这样就避免了在开发中频繁去打包这些库
	【】压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片

	3、对开发体验的优化：
	【】lint：使用 eslint、stylelint 等工具保证团队代码风格一致
	【】HMR：使用热更新避免页面刷新导致的状态丢失，提升开发体验
	


六、vue 性能优化
	1、路由懒加载、异步组件、防抖、节流

	2、v-for 使用 key：对于通过循环生成的列表，应给每个列表项一个稳定且唯一的key，这有利于在列表变动时，尽量少的删除、新增、改动元素

	3、使用冻结的对象：冻结的对象不会被响应化

	4、使用函数式组件：参见函数式组件

	5、使用计算属性：（合理使用 computed 和 watch）如果模板中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存它们

	6、非实时绑定的表单项：
	当使用 v-model 绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致 vue 发生重渲染（rerender），这会带来一些性能的开销。
	特别是当用户改变表单项时，页面有一些动画正在进行中，由于 JS 执行线程和浏览器渲染线程是互斥的，最终会导致动画出现卡顿。
	我们可以通过使用 lazy 或不使用 v-model 的方式解决该问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。

	7、保持对象引用稳定：在绝大部分情况下，vue 触发 rerender 的时机是其依赖的数据发生变化。若数据没有发生变化，哪怕给数据重新赋值了，vue 也是不会做出任何处理的。下面是 vue 判断数据没有变化的源码
// value 为旧值， newVal 为新值
if (newVal === value || (newVal !== newVal && value !== value)) {
  return
}
因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染。

对于原始数据类型，保持其值不变即可
对于对象类型，保持其引用不变即可
从另一方面来说，由于可以通过保持属性引用稳定来避免子组件的重渲染，那么我们应该细分组件来尽量避免多余的渲染

	8、使用 v-show 替代 v-if ：（ v-for 的同时避免使用 v-if ）对于频繁切换显示状态的元素，使用 v-show 可以保证虚拟 dom 树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量 dom 元素的节点，这一点极其重要。
关键字：频繁切换显示状态、内部包含大量dom元素

	9、使用延迟装载（defer）：
	首页白屏时间主要受到两个因素的影响：
	（1）打包体积过大：巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个<div>，没有可显示的内容
	（2）需要立即渲染的内容太多：JS传输完成后，浏览器开始执行JS构造页面。但可能一开始要渲染的组件太多，不仅JS执行的时间很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏。

打包体积过大需要自行优化打包体积，使用 webpack 的 plugin 插件压缩文件。
渲染内容太多的问题，一个可行的办法就是延迟装载组件，让组件按照指定的先后顺序依次一个一个渲染出来。延迟装载是一个思路，本质上就是利用 requestAnimationFrame 事件分批渲染内容，它的具体实现多种多样

	10、第三方插件按需引入

	11、使用缓存（客户端缓存、服务端缓存）优化、服务端开启 gzip 压缩

	12、destory 时销毁事件：比如 addEventListener 添加的事件、setTimeout、setInterval、bus.$on 绑定的监听事件等

	13、使用 keep-alive
	keep-alive 组件是 vue 的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive 内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面可以保留组件的状态。
	keep-alive 具有 include 和 exclude 属性，通过它们可以控制哪些组件进入缓存。另外它还提供了 max 属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue 会移除最久没有使用的组件缓存。
	受 keep-alive 的影响，其内部所有嵌套的组件都具有两个生命周期钩子函数，分别是 activated 和 deactivated，它们分别在组件激活和失活时触发。第一次 activated 触发是在 mounted 之后

	在具体的实现上，keep-alive 在内部维护了一个 key 数组和一个缓存对象
	// keep-alive 内部的声明周期函数
	created () {
	  this.cache = Object.create(null)
	  this.keys = []
	}
	key 数组记录目前缓存的组件 key 值，如果组件没有指定 key 值，则会为其自动生成一个唯一的 key 值。

	cache 对象以 key 值为键，vnode 为值，用于缓存组件对应的虚拟 DOM。在 keep-alive 的渲染函数中，其基本逻辑是判断当前渲染的 vnode 是否有对应的缓存，如果有，从缓存中读取到对应的组件实例；如果没有则将其缓存。当缓存数量超过 max 数值时，keep-alive 会移除掉 key 数组的第一个元素

	14、长列表优化
	【】虚拟滚动（Virtual Scrolling）：虚拟滚动是一种技术，它只渲染当前可见区域的列表项，而不是将整个列表都渲染到 DOM。通过动态添加和删除列表项，可以在滚动时实现高性能和流畅的体验。一些流行的虚拟滚动库包括 Vue Virtual Scroller 和 vue-virtual-scroll-list。
	【】分页加载（Pagination）：将长列表分割成多个页面或加载更多的方式，可以减少一次性加载大量数据所带来的性能问题。通过分页加载，只在需要时加载当前页面的数据，对服务器和客户端的资源消耗更加平衡。
	【】惰性渲染（Lazy Rendering）：惰性渲染是指延迟加载非首屏可见的列表项，只在需要时才进行加载。例如，当用户滚动到某个列表项时，再进行加载和显示。这可以减少初始加载时的渲染时间，提高页面响应速度。
	【】列表项重用（Item Recycling）：在滚动过程中，可以重用已渲染的列表项，而不是每次滚动都重新创建新的列表项。通过将已滚出视图的列表项进行回收和重用，可以减少 DOM 操作和内存占用。
	【】懒加载（Lazy Loading）：对于包含大量图片或复杂内容的列表项，可以采用懒加载的方式。只有当列表项进入可视区域时，才加载其内容，而不是一次性加载所有的内容。这可以加快初始渲染速度和降低资源消耗。
	【】数据缓存和分页缓存：在处理长列表时，可以使用数据缓存和分页缓存来减少重复的数据请求和处理。通过将已获取的数据进行缓存，可以避免重复请求同一数据。同时，对于已加载的分页数据，可以将其缓存起来，以便在用户返回之前的页面时快速恢复。
	【】搜索和过滤优化：针对长列表的搜索和过滤功能，可以使用索引或缓存来加速搜索过程，避免每次搜索都遍历整个列表。
		




前端优化大量数据
  1、冲数据上解决：前端分页分表展示数据，后端分段吐出数据
  2、冲渲染上解决：1异步渲染：等页面加载好后再渲染
                              2局部渲染：先渲染目前可见区域的数据，然后再渲染此屏的数据


link：https://juejin.cn/post/7194400984490049573?#comment




