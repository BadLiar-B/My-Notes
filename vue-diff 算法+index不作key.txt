一、key 的作用
	key 是用来给节点一个唯一的标识，使我们的 diff 操作更准确更快速，高效的更新虚拟 DOM。
	diff 算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的 key 与旧节点进行比对，从而找到相应旧节点。

index 不作 key 原因：
1、使用 index 作为 key，当破坏顺序操作的时候， 因为每一个节点都找不到对应的 key，导致部分节点不能复用，所有的新 vnode 都需要重新创建。会导致 diff 中的优化失效（降低了复用性，违背了虚拟 DOM 的初衷）。原本可以复用的东西，不能被复用，徒然增加了性能开销，浪费性能。（数组的 reverse 方法）
2、使用 index 作为 key 时，在删除数据时，因为 vue 不会深入地区对比子组件的文本内容，所以会错误移除 VDOM 中的节点（index 的值是不固定的）。（当用 index 作为 key 时，因为 diff 算法会就地更新，会复用 key:0 的这个节点，比对的时候，key:0 的节点存在，则比对 key:1，也存在，而多出了 key:2，则会将其删除。）（数组的 splice（0,1）方法）
3、也不能使用随机数作为 key：因为 key 值无论是删除还是反转，根本就不能找到相同的 key，diff 算法就毫无意义了，压根没有复用性可言。

解决方案：
1、在开发中最好每条数据使用唯一标识固定的数据作为 key，比如后台返回的 ID，手机号，身份证号等唯一值
2、可以采用 Symbol 作为 key，Symbol 是 ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。
3、可以采用 uuid 作为 key ，uuid 是 Universally Unique Identifier 的缩写，它是在一定的范围内（从特定的名字空间到全球）唯一的机器生成的标识符



二、请阐述 vue 的 diff 算法：
当组件创建和更新时，vue 均会执行内部的 update 函数，该函数使用 render 函数生成的虚拟 dom 树，将新旧两树进行对比，找到差异点，最终更新到真实 dom
对比差异的过程叫 diff，vue 在内部通过一个叫 patch 的函数完成该过程
在对比时，vue 采用深度优先、同层比较的方式进行比对。
在判断两个节点是否相同时，vue 是通过虚拟节点的 key 和 tag 来进行判断的
具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实 dom 的引用挂到新节点上，然后根据需要更新属性到真实 dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实 dom，同时挂到对应虚拟节点上，然后移除掉旧的 dom。
在对比其子节点数组时，vue 对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实 dom，尽量少的销毁和创建真实 dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实 dom 到合适的位置。
这样一直递归的遍历下去，直到整棵树完成对比。

（diff 算法过程：详细版本 答出上面的就可以
首先，我们拿到新旧节点的数组，然后初始化四个指针，分别指向新旧节点的开始位置和结束位置，进行两两对比，若是 新的开始节点和旧开始节点相同，则都向后面移动，若是结尾节点相匹配，则都前移指针。若是新开始节点和旧结尾节点匹配上了，则会将旧的结束节点移动到旧的开始节点前。若是旧开始节点和新的结束节点相匹配，则会将旧开始节点移动到旧结束节点的后面。若是上述节点都没配有匹配上，则会进行一个兜底逻辑的判断，判断开始节点是否在旧节点中，若是存在则复用，若是不存在则创建。最终跳出循环，进行裁剪或者新增，若是旧的开始节点小于旧的结束节点，则会删除之间的节点，反之则是新增新的开始节点到新的结束节点。
在 patchVnode 过程中会调用 updateChildren，所以 vue 的 diff 算法是个深度优先算法）



三、vue2.x 和 vue3.x 渲染器的 diff 算法：
正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从O(n^3) -> O(n)，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。

Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

Vue3.x 借鉴了 ivi 算法和 inferno 算法

在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。该算法中还运用了动态规划的思想求解最长递归子序列。





